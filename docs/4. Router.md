# Router

The routes can be created in two ways; through the main `server()`, or through the `router()` (from `import { router } from '@server/next';`).

<details title="When to use methods like .get() vs the router()?">
For simple applications just using the `server()` instance is usually enough and recommended. But once you start to have too many routes (a good rule of thumb is 10 routes), it's convenient to split into different files.
</details>

Let's see first a simple example of how to define different routes:

```js
import server from '@server/next';

export default server()
  .get('/', () => 'Hello from the homepage')
  .get('/info', () => '<p>Greetings from the info page</p>')
  .post('/contact', ctx => {
    console.log(ctx.data);
    return 'Message sent successfully';
  })
  .put('/users/:id', ctx => {
    console.log(ctx.url.params.id, ctx.data);
    return 200;
  });
````

A route is composed of 3 parts: the method, the path, and the middleware:

```js
.METHOD(PATH, ...MIDDLEWARE)
````

The method can be any of the well-known HTTP methods:

- `get()`: Used to request data from a specified resource. Does not accept a body.
- `post()`: Used to send data to a server to create/update a resource. Accepts a body.
- `put()`: Used to update a current resource with new data. Accepts a body.
- `delete()`: Used to delete a specified resource. Does not accept a body.
- `patch()`: Used to apply partial modifications to a resource. Accepts a body.
- `options()`: Used to describe the communication options for the target resource. Does not accept a body.
- `head()`: Similar to GET, but it requests a response without the body content. Does not accept a body.

The path is detailed [in the path documentation](#path), but generally is one of these: omitted, an exact match, a parameter-based path, or a wildcard path:

- *omitted*: it will match any path, in the router it is the same as `*`
- `/info`: exact match to `localhost:3000/info`
- `/posts/:id`: a match by parameter
- `/posts/:id(number)`: a match by parameter, including types
- `/posts/*`: a match to any sub-path that has not been previously matched

Finally, the middleware is a function that gets called when both the method and paths match the current request. There are two types, one is a simple middleware that does *not* return anything; no return, `return undefined`, `return null` or `return false` all work like that. These will be called in sequence as detailed below, until finding a middleware that returns something or there is no middleware left.

```js
export default server()
  .use(middleware1)
  .get('/', middleware2, middleware3, middleware4);
```

In this example, when opening `http://localhost:3000/` in the browser, the middleware will be called in order of `middleware1`, then `middleware2`, then `middleware3`, and finally `middleware4`. This is assuming 1, 2, and 3 do not return, because if they return then it'll not be called.

If in that example middleware 4 returns something, that will be used to respond to the browser. If it does not, a 404 will be triggered, since once a method is matched it will not continue to other methods.

### For express users

There are 2 key differences between express.js and server.js, with the goal of making it very obvious what paths are being matched by requests:

- Paths do not match subpaths by default. This means that if you write `.get('/')` and the browser calls `/info`, that path will _not_ get matched. If you want that funcionality, please be more explicit and write `.get('/*')`.
- Only one HTTP method match for server.js. Once a method is matched, no other method can be matched. This means that if you write `.get('/*')` and then `.get('/info')`, that one can never be matched since all the paths go into the first one. For this, please write the `.get('/info')` paths first.

These are made so that it's immediately clear what is being matched when. There are few small disadvantages to be aware because of this:

It's not so easy to do partial matches, e.g. if you want to do `.get('/admin/*', authMiddleware).get('/admin/settings', ...)` that wouldn't work because only the first method is matched. We prefer explicit controls in server.js over some automation. You can then do either:

```js
// More explicit controls
export default server()
  .get('/admin/settings', authMiddleware, settingsReply)
  .get('/admin/users', authMiddleware, usersReply);


// Or keep it
export default server()
  .use(ctx => {
    // Only for GET methods
    if (ctx.method !== 'get') return;
    // Ignore non-admin paths
    if (ctx.url.pathname.startsWith('/admin/')) return;

    // Apply the auth logic
    // ...
  })
  .get('/admin/settings', settingsReply)
  .get('/admin/users', usersReply);
```

But for the second example, we strongly recommend going directly to the router:

```js
import server, { router } from '@server/next';

const authRoutes = router(authMiddleware)
  .get('/admin/settings', settingsReply)
  .get('/admin/users', usersReply);

export default server()
  .use('/admin/*', authRoutes);
````


## Parameters

The route parameters are represented in the path as `/:name` and then are passed as a string to `ctx.url.params.name` (see [`url` docs as well](#url)):

```js
export default server()
  .get('/:page', ctx => ({
    page: ctx.url.params.page,
    name: ctx.url.query.name
  }));

// test.js
const { body } = await app.test().get('/hello?name=Francisco');
expect(body).toEqual({ page: 'hello', name: 'Francisco' });
```

Parameters can _also_ have types explicitly set, in which case they will be casted to that type. There's only 3 possible types, `string` (default), `number` and `date`:

```js
// When requesting `/users/25
export default server().get('/users/:id(number)', ctx => {
  console.log(ctx.url.path, ctx.url.params.id, typeof ctx.url.params.id);
  // /users/25  25  number
});

// When requesting `/calendar/2025-01-01`
export default server().get('/calendar/:day(date)', ctx => {
  const day = ctx.url.params.day;
  console.log(day, day instanceof Date);
  // Date('2025-01-01)  true
});
```


## Wildcards

By default path matches are exact ([unlike express.js](#for-express-users)):

```js
import server, { view } from '@server/next';

export default server()
  .get('/', ctx => view('home.html'))
  .get('/info', ctx => view('info.html'));
```
